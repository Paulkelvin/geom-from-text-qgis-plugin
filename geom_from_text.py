# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeomFromText
                                 A QGIS plugin
 This plugin creates new cadastre parcels and beacons
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-03-28
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Sivan Design D.S. Ltd.
        email                : guy.magen@sivandesign.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QDate
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from qgis.core import (QgsVectorLayer,
                       QgsMapLayer,
                       QgsFeature,
                       QgsDataSourceUri,
                       QgsGeometry,
                       QgsPointXY,
                       QgsProject,
                       QgsCoordinateTransform,
                       QgsCoordinateReferenceSystem,
                       Qgis,
                       QgsVectorLayerUtils,
                       QgsFillSymbol,
                       QgsFeatureRequest,
                       QgsMessageLog)
from qgis import processing
import configparser
from datetime import date
import sys
import subprocess

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .geom_from_text_dialog import GeomFromTextDialog, GeomFromTextReview
import os.path

class GeomFromText:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GeomFromText_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Geom from Text')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GeomFromText', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/geom_from_text/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Add parcels from CSV'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Geom from Text'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GeomFromTextDialog()
            self.dlgRev = GeomFromTextReview()

        
        # keep dialog window on top
        self.dlg.setWindowFlags(Qt.WindowStaysOnTopHint)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:

            # ----------------------------------------- geom_from_text code -----------------------------------------
            ### Dialog window inputs ###

            # get file path from the QgsFileWigdet in the user dialog
            csv_path = self.dlg.qfw.filePath()

            # get crs from comboBox in the user dialog
            epsg = self.dlg.cmb.itemData(self.dlg.cmb.currentIndex())

            # get application number from the lineEdit in the user dialog
            app_num = self.dlg.ldt.text().strip()
            
            # -------------------------------------------------------------------------------------------------------
            ### Functions ###
            
            # create road feature from point features list and offset value
            def createRoadFeature(points_list, roads_lyr, offset, tr=None):
                # create line geom
                line_geom = QgsGeometry.fromPolylineXY(points_list)
                # transform
                if tr: line_geom.transform(tr)
                # offset geom
                line_geom = line_geom.offsetCurve(offset, 8, QgsGeometry.JoinStyleMiter, 2)
                # create line feature
                fields = roads_lyr.fields()
                line_feat = QgsFeature(fields)
                # set offset attribute
                line_feat.setAttribute(fields.indexFromName('offset'), offset)
                line_feat.setGeometry(line_geom)
                
                return line_feat
            
            # create UPI components using a polygon feature - LGA, Block Number and Parcel Number
            def createUPI(poly_feat, lga_lyr, blocks_lyr, parcel_lkp):
                # create centroid point layer
                centroid = poly_feat.geometry().centroid()
                point_feat = QgsFeature()
                point_feat.setGeometry(centroid)
                point_lyr = QgsVectorLayer('Point?crs=epsg:26331', 'point', 'memory')
                point_lyr.dataProvider().addFeatures([point_feat])
                
                # get LGA number
                out = processing.run("native:joinattributesbylocation", {'INPUT':point_lyr,
                                                                         'PREDICATE':[0],
                                                                         'JOIN':lga_lyr,
                                                                         'JOIN_FIELDS':['lga_num'],
                                                                         'METHOD':0,
                                                                         'DISCARD_NONMATCHING':False,
                                                                         'PREFIX':'',
                                                                         'OUTPUT':'memory:'})['OUTPUT']
                lga_num = [feat['lga_num'] for feat in out.getFeatures()][0]
                
                # get block number
                out = processing.run("native:joinattributesbylocation", {'INPUT':point_lyr,
                                                                         'PREDICATE':[0],
                                                                         'JOIN':blocks_lyr,
                                                                         'JOIN_FIELDS':['block_num'],
                                                                         'METHOD':0,
                                                                         'DISCARD_NONMATCHING':False,
                                                                         'PREFIX':'',
                                                                         'OUTPUT':'memory:'})['OUTPUT']
                block_num = [feat['block_num'] for feat in out.getFeatures()][0]
                if not(block_num): block_num = 999 # undefined

                # get parcel number
                if block_num != 999:
                    # select by block number
                    expression = "(\"block_num\" = '{}')".format(block_num) + ' AND ' + "(\"lga_num\" = '{}')".format(lga_num)
                    parcel_lkp.selectByExpression(expression)
                    if parcel_lkp.selectedFeatures():
                        counter = parcel_lkp.selectedFeatures()[0]
                        parcel_count = counter['parcel_count'] + 1
                        parcel_lkp.removeSelection()
                        # update counter
                        parcel_lkp.startEditing()
                        counter['parcel_count'] = parcel_count
                        parcel_lkp.updateFeature(counter)
                    else:
                        # create new block parcel counter
                        fields = parcel_lkp.fields()
                        counter = QgsFeature(fields)
                        # set attributes
                        counter.setAttribute(fields.indexFromName('lga_num'), lga_num)
                        counter.setAttribute(fields.indexFromName('block_num'), block_num)
                        counter.setAttribute(fields.indexFromName('parcel_count'), 1)
                        # add feature
                        parcel_lkp.startEditing()
                        parcel_lkp.addFeature(counter)
                        parcel_count = 1
                    parcel_num = parcel_count
                else:
                    parcel_num = None
                
                return (lga_num, block_num, parcel_num)
                    
            # -------------------------------------------------------------------------------------------------------
            ### DBSERVER layers connection ###

            # INI file path
            ini_path = os.path.join(self.plugin_dir, 'config.ini')
            # read INI file
            config = configparser.ConfigParser()
            config.read(ini_path)
            # get connection settings
            host = config['PG']['Host'].strip()
            port = config['PG']['Port'].strip()
            database = config['PG']['Database'].strip()
            username = config['PG']['UserName'].strip()
            password = config['PG']['Password'].strip()
            data_source = config['DEFAULT_FIELDS']['DataSource'].strip() # default data source value
            status = config['DEFAULT_FIELDS']['Status'].strip() # default status value

            # set connection
            uri = QgsDataSourceUri()
            uri.setConnection(host, port, database, username, password)

            # set Beacons layer
            uri.setDataSource('public', 'land_registration___beacons', 'geometry', '')
            beacons = QgsVectorLayer(uri.uri(), 'beacons', 'postgres')
            # set Parcels layer
            uri.setDataSource('public', 'land_registration___parcels', 'geometry', '')
            parcels = QgsVectorLayer(uri.uri(), 'parcels', 'postgres')
            # set Blocks layer
            uri.setDataSource('public', 'land_registration___blocks', 'geometry', '')
            blocks = QgsVectorLayer(uri.uri(), 'blocks', 'postgres')
            # set LGA layer
            uri.setDataSource('public', 'ogun_admin___lgas', 'geometry', '')
            lga = QgsVectorLayer(uri.uri(), 'lga', 'postgres')
            # set Parcel Roads layer
            uri.setDataSource('public', 'land_registration___parcel_roads', 'geom', '')
            roads = QgsVectorLayer(uri.uri(), 'roads', 'postgres')
            # set Parcel Lookup table
            uri.setDataSource('public', 'land_registration___parcel_lookup', '', '')
            parcel_lkp = QgsVectorLayer(uri.uri(), 'parcel_lkp', 'postgres')

            # -------------------------------------------------------------------------------------------------------
            ### set transformation ###

            if epsg in [26391, 32631]:
                from_crs = QgsCoordinateReferenceSystem.fromEpsgId(epsg) # NNO or WGS84 / UTM zone 31N
                to_crs = QgsCoordinateReferenceSystem.fromEpsgId(26331) # Minna / UTM zone 31N
                tr = QgsCoordinateTransform(from_crs, to_crs, QgsProject.instance())
            else:
                tr = None

            # -------------------------------------------------------------------------------------------------------
            ### read csv and create new features ###
            
            # new features lists
            parcel_points = [] # QgsPoint list
            road_points = [] # QgsPoint list
            beacons_feats = [] # QgsFeature list
            parcels_feats = [] # QgsFeature list
            roads_feats = [] # QgsFeature list

            # dictionaries
            '''
            dictionaries that maintains a list of features for each parcel_id
            '''
            beacons_dict = {}
            roads_dict = {}

            # fields
            parcels_fields = parcels.fields()
            beacons_fields = beacons.fields()

            # error indicator
            is_error = False

            # offset indicator
            is_offset = False

            # read csv
            with open(csv_path, 'r') as crds:
                
                # list of rows
                rows = crds.readlines()

                # first row after headers
                first_row = rows[1].strip().split(',') # list of strings
                
                # new parcel indicator
                current_parcel_id = first_row[0]

                # initial bearing and distance
                try:
                    bearing = float(first_row[4]) + float(first_row[5]) / 60
                    dist = float(first_row[6])
                except:
                    pass
                    
                # 1st point
                try:
                    first_point = QgsPointXY(float(first_row[2]), float(first_row[3]))
                except:
                    is_error = True
                    QMessageBox.critical(self.iface.mainWindow(),
                                        'Error',
                                        'No XY values for starting point.\nPlease check 1st Parcel')
                    self.iface.messageBar().pushMessage('Error', 'Failed to add parcels', level=Qgis.Critical, duration=3)

                # iterate points
                if not is_error:
                    for row in rows[1:]:
                        
                        # convert one string to a list of strings
                        row = row.strip().split(',')
                        
                        # attributes
                        parcel_id = row[0]
                        beacon_num = row[1]

                        # process 1st parcel only - web service modification
                        if parcel_id != current_parcel_id:
                            break

                        # xy values indicator
                        is_xy = False
                        
                        # get xy values
                        if row[2] and row[3]:
                            is_xy = True
                            try:
                                x = float(row[2])
                                y = float(row[3])
                            except:
                                is_error = True
                                QMessageBox.critical(self.iface.mainWindow(),
                                                    'Error',
                                                    'Invalid XY value.\nPlease check Parcel: {}, Beacon: {}'.format(parcel_id, beacon_num))
                                self.iface.messageBar().pushMessage('Error', 'Failed to add parcels', level=Qgis.Critical, duration=3)
                                break
                        
                        # get bearing and distance values
                        if all(row[4:7]):
                            try:
                                new_bearing = float(row[4]) + float(row[5]) / 60
                                new_dist = float(row[6])
                            except:
                                is_error = True
                                QMessageBox.critical(self.iface.mainWindow(),
                                                    'Error',
                                                    'Invalid Bearing/Distance value.\nPlease check Parcel: {}, Beacon: {}'.format(parcel_id, beacon_num))
                                self.iface.messageBar().pushMessage('Error', 'Failed to add parcels', level=Qgis.Critical, duration=3)
                                break
                        else:
                            new_bearing = None
                            new_dist = None
                        
                        # create point
                        if is_xy:
                            point = QgsPointXY(x, y)
                        else:
                            # project previous point
                            point = point.project(dist, bearing)
                            
                        # set new bearing and distance
                        bearing = new_bearing
                        dist = new_dist
                        
                        # code for the same parcel
                        if parcel_id == current_parcel_id:
                            # add parcel point
                            parcel_points.append(point)

                            # add road feature
                            '''
                            if previous row has offset value use current and previous point to create new road feature
                            road segment is made from two points only
                            '''
                            if is_offset:
                                # add 2nd point
                                road_points.append(point)
                                # create road feature
                                road_feat = createRoadFeature(road_points, roads, offset, tr)
                                roads_feats.append(road_feat)
                                # reset
                                road_points = []
                                is_offset = False

                            # add 1st point
                            if row[7]:
                                offset = float(row[7])
                                road_points.append(point)
                                is_offset = True

                            # add beacon feature
                            point_geom = QgsGeometry.fromPointXY(point)
                            if tr: point_geom.transform(tr)
                            new_beacon = QgsFeature(beacons_fields) # create feature
                            new_beacon.setAttribute(beacons_fields.indexFromName('beacon_num'), beacon_num)
                            new_beacon.setAttribute(beacons_fields.indexFromName('x'), point.x())
                            new_beacon.setAttribute(beacons_fields.indexFromName('y'), point.y())
                            new_beacon.setAttribute(beacons_fields.indexFromName('date_created'), QDate(date.today()))
                            new_beacon.setGeometry(point_geom) # set geometry
                            beacons_feats.append(new_beacon)

                        # code for a new parcel
                        else:
                            if not is_xy:
                                # error
                                is_error = True
                                QMessageBox.critical(self.iface.mainWindow(),
                                                    'Error',
                                                    'No XY values for starting point.\nPlease check Parcel: {}'.format(parcel_id))
                                self.iface.messageBar().pushMessage('Error', 'Failed to add parcels', level=Qgis.Critical, duration=3)
                                break

                            # reset bearing and distance
                            bearing = new_bearing
                            dist = new_dist

                            # add new parcel
                            poly = QgsGeometry.fromPolygonXY([parcel_points]) # QgsPolygon
                            # validate geometry
                            if not poly.validateGeometry():
                                if tr: poly.transform(tr)
                                new_parcel = QgsFeature(parcels_fields) # feature
                                new_parcel.setGeometry(poly) # geometry
                                area = poly.area()
                                atts = createUPI(new_parcel, lga, blocks, parcel_lkp)
                                lga_num = atts[0]
                                block_num = atts[1]
                                parcel_num = atts[2]
                                new_parcel.setAttribute(parcels_fields.indexFromName('lga_num'), lga_num)
                                new_parcel.setAttribute(parcels_fields.indexFromName('block_num'), block_num)
                                new_parcel.setAttribute(parcels_fields.indexFromName('parcel_num'), parcel_num)
                                new_parcel.setAttribute(parcels_fields.indexFromName('area'), area)
                                new_parcel.setAttribute(parcels_fields.indexFromName('data_source'), data_source)
                                new_parcel.setAttribute(parcels_fields.indexFromName('status'), status)
                                new_parcel.setAttribute(parcels_fields.indexFromName('date_created'), QDate(date.today()))
                                parcels_feats.append(new_parcel)
                                # add parcel point
                                parcel_points = [point] # new list
                            else:
                                # discard lookup parcel count
                                parcel_lkp.rollBack()
                                # error
                                is_error = True
                                QMessageBox.critical(self.iface.mainWindow(),
                                                    'Error',
                                                    'Invalid Parcel geometry.\nPlease check Parcel: {}'.format(current_parcel_id))
                                self.iface.messageBar().pushMessage('Error', 'Failed to add parcels', level=Qgis.Critical, duration=3)
                                break
                            
                            # add road feature
                            '''
                            if we have offset value in the last row of a parcel group
                            we need to create a road between last point and first point
                            '''
                            # set 1st point
                            first_point = point

                            if is_offset:
                                # add first point
                                road_points.append(first_point)
                                # create road feature
                                road_feat = createRoadFeature(road_points, roads, offset, tr)
                                roads_feats.append(road_feat)
                                # reset
                                road_points = []
                                is_offset = False
                            
                            # add 1st point
                            if row[7]:
                                offset = float(row[7])
                                road_points.append(point)
                                is_offset = True

                            # add roads features to dict
                            if current_parcel_id in roads_dict:
                                roads_dict[current_parcel_id].append(roads_feats)
                            else:
                                roads_dict[current_parcel_id] = roads_feats
                            roads_feats = []

                            # add beacon
                            point_geom = QgsGeometry.fromPointXY(first_point)
                            if tr: point_geom.transform(tr)
                            new_beacon = QgsFeature(beacons_fields) # create feature
                            new_beacon.setAttribute(beacons_fields.indexFromName('beacon_num'), beacon_num)
                            new_beacon.setAttribute(beacons_fields.indexFromName('x'), first_point.x())
                            new_beacon.setAttribute(beacons_fields.indexFromName('y'), first_point.y())
                            new_beacon.setAttribute(beacons_fields.indexFromName('date_created'), QDate(date.today()))
                            new_beacon.setGeometry(point_geom) # set geometry
                            
                            # add beacons features to dict
                            beacons_dict[current_parcel_id] = beacons_feats
                            beacons_feats = [new_beacon]
                            current_parcel_id = parcel_id # new parcel
                            
                if not is_error:
                    # add last parcel
                    poly = QgsGeometry.fromPolygonXY([parcel_points]) # QgsPolygon
                    # validate geometry
                    '''
                    if the last parcel geometry is valid we can add all features to the layers
                    and update the parcel lookup table
                    '''
                    if not poly.validateGeometry():
                        if tr: poly.transform(tr)
                        new_parcel = QgsFeature(parcels_fields) # feature
                        new_parcel.setGeometry(poly) # geometry
                        area = poly.area() # area
                        atts = createUPI(new_parcel, lga, blocks, parcel_lkp)
                        lga_num = atts[0]
                        block_num = atts[1]
                        parcel_num = atts[2]
                        new_parcel.setAttribute(parcels_fields.indexFromName('lga_num'), lga_num)
                        new_parcel.setAttribute(parcels_fields.indexFromName('block_num'), block_num)
                        new_parcel.setAttribute(parcels_fields.indexFromName('parcel_num'), parcel_num)
                        new_parcel.setAttribute(parcels_fields.indexFromName('area'), area)
                        new_parcel.setAttribute(parcels_fields.indexFromName('data_source'), data_source)
                        new_parcel.setAttribute(parcels_fields.indexFromName('status'), status)
                        new_parcel.setAttribute(parcels_fields.indexFromName('date_created'), QDate(date.today()))
                        parcels_feats.append(new_parcel)
                        
                        # add last road feature
                        if is_offset:
                            road_points.append(first_point)
                            road_feat = createRoadFeature(road_points, roads, offset, tr)
                            roads_feats.append(road_feat)
                        # add roads features to dict
                        if parcel_id in roads_dict:
                            roads_dict[parcel_id].append(roads_feats)
                        else:
                            roads_dict[parcel_id] = roads_feats
                        
                        # add beacons features to dict
                        beacons_dict[parcel_id] = beacons_feats

                    else:
                        # discard lookup parcel count
                        parcel_lkp.rollBack()
                        is_error = True
                        # error
                        QMessageBox.critical(self.iface.mainWindow(),
                                            'Error',
                                            'Invalid Parcel geometry.\nPlease check Parcel: {}'.format(current_parcel_id))
                        self.iface.messageBar().pushMessage('Error', 'Failed to add new parcels', level=Qgis.Critical, duration=3)

                    # -------------------------------------------------------------------------------------------------------
                    ### new parcels review process ###

                    if not(is_error):
                        # map canvas
                        canvas = self.iface.mapCanvas()
                        
                        # zoom function
                        def zoomToLayer(layer):
                            canvas.setExtent(layer.extent().scaled(1.4))
                            canvas.refresh()
                        
                        # user approval indicator
                        all_approved = True

                        # display each parcel feature
                        for parcel in parcels_feats:
                            parcel_lyr = QgsVectorLayer('Polygon?crs=epsg:26331', 'New Parcel', 'memory') # temp layer
                            parcel_lyr.dataProvider().addFeatures([parcel])
                            parcel_lyr.setFlags(QgsMapLayer.LayerFlag(8)) # set private and required
                            #parcel_lyr.setFlags(QgsMapLayer.LayerFlag(0)) # set required
                            #parcel_lyr.setReadOnly(True)
                            # set symbology
                            symbol = QgsFillSymbol.createSimple({'outline_style': 'solid', 'outline_width': '0.66', 'outline_color': 'yellow', 'color':'0,0,0,0'})
                            parcel_lyr.renderer().setSymbol(symbol)
                            # connect zoom function to zoom button
                            self.dlgRev.btnZoom.clicked.connect(lambda: zoomToLayer(parcel_lyr))
                            # add layer on top and zoom
                            root = QgsProject.instance().layerTreeRoot()
                            root.insertLayer(0, parcel_lyr)
                            zoomToLayer(parcel_lyr)
                            # open parcel review dialog
                            self.dlgRev.setWindowFlags(Qt.WindowStaysOnTopHint)
                            self.dlgRev.show()
                            result = self.dlgRev.exec_()
                            # remove layer
                            root.removeLayer(parcel_lyr)
                            canvas.refresh()
                            if result:
                                continue
                            else:
                                all_approved = False
                                QMessageBox.critical(self.iface.mainWindow(),
                                            'Error',
                                            'Parcel disapproved by user')
                                self.iface.messageBar().pushMessage('Error', 'Failed to add new parcels', level=Qgis.Critical, duration=3)
                                break
                        
                        # -------------------------------------------------------------------------------------------------------
                        ### add new parcels ###
                        
                        if all_approved:
                            '''
                            the next code line updates the new features and outputs a list of the last added features
                            '''
                            new_parcels = parcels.dataProvider().addFeatures(parcels_feats)[1]
                            
                            # set missing parcel_num values
                            '''
                            1) replacing empty parcel_num values with qgs_fid values for all parcels that are not within a block
                            2) create upi_dict to map upi values for each parcel_id
                            *necessary for matching upi values to each road/beacon feature
                            '''
                            # new parcels ids
                            new_ids = [feat.id() for feat in new_parcels]
                            # select new parcels
                            parcels.select(new_ids)
                            # update parcel_num
                            parcels.startEditing()
                            for feat in parcels.selectedFeatures():
                                if not feat['parcel_num']:
                                    # set parcel_num to qgis_fid
                                    parcels.changeAttributeValue(feat.id(), parcels_fields.indexFromName('parcel_num'), feat.id())
                            parcels.commitChanges()
                            # create upi components lists
                            lga_nums = QgsVectorLayerUtils.getValues(parcels, 'lga_num', selectedOnly=True)[0]
                            block_nums = QgsVectorLayerUtils.getValues(parcels, 'block_num', selectedOnly=True)[0]
                            parcel_nums = QgsVectorLayerUtils.getValues(parcels, 'parcel_num', selectedOnly=True)[0]
                            parcels.removeSelection()
                        
                            # create upi_dict
                            '''
                            dictionary that maintains a parcel_num value for each parcel_id
                            '''
                            parcel_ids = list(beacons_dict.keys())
                            upi_dict = dict(zip(parcel_ids, zip(lga_nums, block_nums, parcel_nums)))

                            # add roads
                            for k in roads_dict:
                                for feat in roads_dict[k]:
                                    feat['lga_num'] = upi_dict[k][0]
                                    feat['block_num'] = upi_dict[k][1]
                                    feat['parcel_num'] = upi_dict[k][2]
                                roads.dataProvider().addFeatures(roads_dict[k])

                            # add beacons
                            for k in beacons_dict:
                                for feat in beacons_dict[k]:
                                    feat['lga_num'] = upi_dict[k][0]
                                    feat['block_num'] = upi_dict[k][1]
                                    feat['parcel_num'] = upi_dict[k][2]
                                beacons.dataProvider().addFeatures(beacons_dict[k])
                            
                            # commit parcel lookup changes
                            parcel_lkp.commitChanges()
                            
                            # zoom to new parcels
                            canvas.zoomToFeatureIds(parcels, new_ids)

                            # # message user
                            # if len(new_parcels) == 1:
                            #     msg = 'A new parcel has been added to the layer'
                            # else:
                            #     msg = '{} new parcels have been added to the layer'.format(len(new_parcels))
                            # self.iface.messageBar().pushMessage('Done',
                            #                                     msg,
                            #                                     level=Qgis.Success, duration=3)

                            # -------------------------------------------------------------------------------------------------------
                            ### send_request subprocess ###

                            # feature request with filter expression
                            req = QgsFeatureRequest().setFilterExpression(f'"lga_num" = {lga_num}')

                            # get lga_num from LGA feature request
                            lga_name = None
                            for feat in lga.getFeatures(req):
                                lga_name = feat['lga_name']

                            # path to send_request.py
                            send_request_path = os.path.join(self.plugin_dir, 'send_request.py')

                            # path to QGIS's python
                            qgis_base_dir = os.path.dirname(sys.executable) # C:\\PROGRA~1\\QGIS34~1.7\\bin
                            qgis_python_path = os.path.join(qgis_base_dir, 'python.exe') # C:\\PROGRA~1\\QGIS34~1.7\\bin\\python.exe

                            # construct the command
                            send_request_cmd = [
                                qgis_python_path,
                                send_request_path,
                                app_num, lga_name, str(block_num), str(parcel_num)
                            ]
                            
                            try:
                                # run the subprocess
                                subprocess.run(send_request_cmd, check=True)

                            except subprocess.CalledProcessError:
                                QMessageBox.warning(self.iface.mainWindow(),
                                                     'Warning',
                                                     f'Failed to send Application No. {app_num}\nCheck log file for details')
                                
                            except Exception as e:
                                QMessageBox.warning(self.iface.mainWindow(),
                                                     'Warning',
                                                     f'Failed to send Application No. {app_num}\nUnexpected error occurred:\n{str(e)}')
                                
                            # message user
                            if len(new_parcels) == 1:
                                msg = 'A new parcel has been added to the layer'
                            else:
                                msg = '{} new parcels have been added to the layer'.format(len(new_parcels))
                            self.iface.messageBar().pushMessage('Done',
                                                                msg,
                                                                level=Qgis.Success, duration=3)